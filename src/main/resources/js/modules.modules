MODULE Math;

IMPORT JS;

PROCEDURE ArcCos* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.acos(x)"); RETURN res
END ArcCos;

PROCEDURE ArcCosh* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.acosh(x)"); RETURN res
END ArcCosh;

PROCEDURE ArcSin* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.asin(x)"); RETURN res
END ArcSin;

PROCEDURE ArcSinh* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.asinh(x)"); RETURN res
END ArcSinh;

PROCEDURE ArcTan* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.atan(x)"); RETURN res
END ArcTan;

PROCEDURE ArcTan2* (y, x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.atan2(x)"); RETURN res
END ArcTan2;

PROCEDURE ArcTanh* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.atanh(x)"); RETURN res
END ArcTanh;

PROCEDURE Ceiling* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.ceil(x)"); RETURN res
END Ceiling;

PROCEDURE Cos* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.cos(x)"); RETURN res
END Cos;

PROCEDURE Cosh* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.cosh(x)"); RETURN res
END Cosh;

PROCEDURE Exp* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.exp(x)"); RETURN res
END Exp;

PROCEDURE Exponent* (x: REAL): INTEGER;
BEGIN
RETURN 0
END Exponent;

PROCEDURE Floor* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.floor(x)"); RETURN res
END Floor;

PROCEDURE Frac* (x: REAL): REAL;
BEGIN
RETURN 0.0
END Frac;

PROCEDURE IntPower* (x: REAL; n: INTEGER): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.pow(x, n)"); RETURN res
END IntPower;

PROCEDURE Log* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.log10(x)"); RETURN res
END Log;

PROCEDURE Ln* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.log(x)"); RETURN res
END Ln;

PROCEDURE Mantissa* (x: REAL): REAL;
BEGIN
RETURN 0.0
END Mantissa;

PROCEDURE Pi* (): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.PI"); RETURN res
END Pi;

PROCEDURE Power* (x, y: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.pow(x, y)"); RETURN res
END Power;

PROCEDURE Round* (x: REAL): REAL;
BEGIN
RETURN Floor(x + 0.5)
END Round;

PROCEDURE Sign* (x: REAL): REAL;
VAR res: REAL;
BEGIN
 IF x > 0.0 THEN 
  res := 1.0
 ELSIF x < 0.0 THEN
  res := -1.0
 ELSE
  res := 0.0
 END;
 RETURN res
END Sign;

PROCEDURE Sin* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.sin(x)"); RETURN res
END Sin;

PROCEDURE Sinh* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.sinh(x)"); RETURN res
END Sinh;

PROCEDURE Sqrt* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.sqrt(x)"); RETURN res
END Sqrt;

PROCEDURE Tan* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.tan(x)"); RETURN res
END Tan;

PROCEDURE Tanh* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.tanh(x)"); RETURN res
END Tanh;

PROCEDURE Trunc* (x: REAL): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.trunc(x)"); RETURN res
END Trunc;
 
PROCEDURE Rnd*(): REAL;
VAR res: REAL;
BEGIN JS.do("res = Math.random()"); RETURN res
END Rnd;

END Math.


MODULE Strings; 
 
IMPORT JS;
 
PROCEDURE Len* (str: ARRAY OF CHAR): INTEGER; 
VAR i: INTEGER; 
BEGIN 
 i := 0; WHILE (i < LEN(str)) & (str[i] # 0X) DO INC(i) END; 
 RETURN i 
END Len; 
 
PROCEDURE Join* (VAR str1: ARRAY OF CHAR; str2: ARRAY OF CHAR); 
VAR l1, l2, i: INTEGER; 
BEGIN 
 l1 := Len(str1); l2 := Len(str2); 
 ASSERT(l2 < LEN(str1) - l1);
 i := 0;
 WHILE i < l2 DO str1[l1 + i] := str2[i]; INC(i) END 
END Join; 
  
PROCEDURE RealToString* (arg: REAL; VAR res: ARRAY OF CHAR; fixed: INTEGER); 
VAR i, j, len: INTEGER; string1: ARRAY 64 OF CHAR; 
BEGIN 
 JS.do("string1 = String(arg.toFixed(fixed));"); 
 i := 0; j := 0; 
 len := LEN(string1);
 IF string1[j] # "-" THEN res[i] := " "; INC(i); INC(len) END;
 WHILE i < len DO
  IF string1[j] = "." THEN
   res[i] := "."
  ELSE
   res[i] := string1[j]
  END;
  INC(i); INC(j);
 END;
 WHILE i < LEN(res) DO res[i] := 0X; INC(i) END
END RealToString; 

PROCEDURE IntToString* (arg: INTEGER; VAR res: ARRAY OF CHAR); 
VAR i: INTEGER; string1: ARRAY 64 OF CHAR; 
BEGIN 
 JS.do("string1 = String(arg);"); 
 i := 0; 
 WHILE i < LEN(string1) DO res[i] := string1[i]; INC(i) END; 
 WHILE i < LEN(res) DO res[i] := 0X; INC(i) END 
END IntToString; 
 
END Strings.

MODULE Log;

IMPORT JS, Strings;

PROCEDURE Clear*;
BEGIN
 JS.do("document.getElementById('log').innerHTML = ''")
END Clear;

PROCEDURE String*(arg: ARRAY OF CHAR);
BEGIN
 JS.do("document.getElementById('log').innerHTML = document.getElementById('log').innerHTML + arg.toString().replace(/ /g,'&nbsp;')")
END String;

PROCEDURE Char*(arg: CHAR);
BEGIN
 JS.do("document.getElementById('log').innerHTML = document.getElementById('log').innerHTML + JS.String.fromCharCode(arg)")
END Char;

PROCEDURE Real*(arg: REAL);
BEGIN
 JS.do("document.getElementById('log').innerHTML = document.getElementById('log').innerHTML + arg")
END Real;

PROCEDURE RealForm* (x: REAL; fixed: INTEGER);
VAR str: ARRAY 256 OF CHAR;
BEGIN
 Strings.RealToString(x, str, fixed);
 String(str);
END RealForm;

PROCEDURE Int*(arg: INTEGER); 
BEGIN
 JS.do("document.getElementById('log').innerHTML = document.getElementById('log').innerHTML + arg")
END Int;
 
PROCEDURE Set*(s: SET);
VAR i: INTEGER; first: BOOLEAN;
BEGIN
 first := TRUE;
 String("{");
 FOR i := 0 TO 31 DO
  IF i IN s THEN
   IF ~ first THEN String(",") END;
   Int(i);
   first := FALSE
  END
 END;
 String("}")
END Set;

PROCEDURE Bool*(arg: BOOLEAN); 
BEGIN
 IF arg THEN String("TRUE") ELSE String("FALSE") END
END Bool;

PROCEDURE Ln*; 
BEGIN
 JS.do("document.getElementById('log').innerHTML = document.getElementById('log').innerHTML + '<br>'")
END Ln;

END Log.

MODULE Draw;

IMPORT JS;

CONST
 black* = 000000000H;
 white* = 0FFFFFFFFH;
 red*   = 0FFFF4444H;
 green* = 0FF44FF44H;
 blue*  = 0FF4444FFH;

TYPE
 ProcessingType* = POINTER TO RECORD END; (* dummy type *)
 CallbackType* = PROCEDURE;
 Image* = POINTER TO RECORD END;

VAR
 mouseX*, mouseY*: REAL;
 width*, height*: INTEGER;
 SetupProc, DrawProc, PressedProc, ReleasedProc, OverProc, OutProc: CallbackType;
 Instance, myFont: ProcessingType;
 started, focus*: BOOLEAN;

PROCEDURE CreateCanvas*(target: ARRAY OF CHAR);
BEGIN
 JS.do("var canvas = document.createElement('canvas');
  canvas.id = 'processingCanvas';
  document.getElementById(target).innerHTML = '';
  document.getElementById(target).appendChild(canvas);
 ");
END CreateCanvas;

(* callbacks *)

PROCEDURE SetSetupProc*(s : CallbackType);
BEGIN SetupProc := s
END SetSetupProc;

PROCEDURE SetDrawProc*(d : CallbackType);
BEGIN DrawProc := d
END SetDrawProc;

PROCEDURE SetPressedProc*(c : CallbackType);
BEGIN PressedProc := c
END SetPressedProc;

PROCEDURE SetReleasedProc*(c : CallbackType);
BEGIN ReleasedProc := c
END SetReleasedProc;

PROCEDURE SetOutProc*(c : CallbackType);
BEGIN OutProc := c
END SetOutProc;

PROCEDURE SetOverProc*(c : CallbackType);
BEGIN OverProc := c
END SetOverProc;

(* global *)

PROCEDURE SetFrameRate* (fps : INTEGER);
BEGIN JS.do("Instance.frameRate(fps);")
END SetFrameRate;

PROCEDURE SetBackground*(argb : INTEGER);
BEGIN JS.do("Instance.background(argb)")
END SetBackground;

PROCEDURE SetSize*(w, h : INTEGER);
BEGIN JS.do("Instance.size(w,h);")
END SetSize;

PROCEDURE Fill*(argb : INTEGER);
BEGIN JS.do("Instance.fill(argb)")
END Fill;
 
PROCEDURE NoFill*;
BEGIN JS.do("Instance.noFill()")
END NoFill;

PROCEDURE Stroke*(argb : INTEGER);
BEGIN JS.do("Instance.stroke(argb)")
END Stroke;
 
PROCEDURE NoStroke*;
BEGIN JS.do("Instance.noStroke()")
END NoStroke;

PROCEDURE StrokeWidth*(width : INTEGER);
BEGIN JS.do("Instance.strokeWeight(width)")
END StrokeWidth;

PROCEDURE Smooth*;
BEGIN JS.do("Instance.smooth()")
END Smooth;

PROCEDURE NoSmooth*;
BEGIN JS.do("Instance.noSmooth()")
END NoSmooth;

(* loop *)

PROCEDURE NoLoop*;
BEGIN JS.do("Instance.noLoop()")
END NoLoop;
 
PROCEDURE Loop*;
BEGIN JS.do("Instance.loop()")
END Loop;
 
PROCEDURE Redraw*;
BEGIN JS.do("Instance.redraw()")
END Redraw;
 
(* drawing *)

PROCEDURE Line*(x0, y0, x1, y1: REAL);
BEGIN JS.do("Instance.line(x0,y0,x1,y1)")
END Line;

PROCEDURE Ellipse*(x, y, w, h: REAL);
BEGIN JS.do("Instance.ellipse(x,y,w,h)")
END Ellipse;

PROCEDURE Rect*(x, y, w, h: REAL);
BEGIN JS.do("Instance.rect(x,y,w,h)")
END Rect;

PROCEDURE RectRounded*(x, y, w, h, r: REAL);
BEGIN JS.do("Instance.rect(x,y,w,h,r)")
END RectRounded;

(* drawing with int args *)

PROCEDURE Linei*(x0, y0, x1, y1: INTEGER);
BEGIN JS.do("Instance.line(x0,y0,x1,y1);")
END Linei;
  
PROCEDURE Ellipsei*(x, y, w, h: INTEGER);
BEGIN JS.do("Instance.ellipse(x,y,w,h);")
END Ellipsei;
  
PROCEDURE Recti*(x, y, w, h: INTEGER);
BEGIN JS.do("Instance.rect(x,y,w,h);")
END Recti;
  
PROCEDURE RectRoundedi*(x, y, w, h, r: INTEGER);
BEGIN JS.do("Instance.rect(x,y,w,h,r);")
END RectRoundedi;

(* math *)

PROCEDURE Radians*(angle : REAL): REAL;
VAR ret: REAL;
BEGIN
 JS.do("ret = Instance.radians(angle)");
 RETURN ret
END Radians;

(* text *)

PROCEDURE SetFont* (name: ARRAY OF CHAR);
BEGIN JS.do("myFont = Instance.loadFont(name)")
END SetFont;
 
PROCEDURE String*(mystr: ARRAY OF CHAR; x, y: REAL; size: INTEGER);
VAR i: INTEGER;
BEGIN
 i := 0; WHILE (i < LEN(mystr)) & (mystr[i] # 0X) DO INC(i) END;
 JS.do("Instance.textFont(myFont); Instance.textSize(size); var newStr = mystr.toString().substring(0, i); Instance.text(newStr, x, y)")
END String;

PROCEDURE Stringi*(mystr: ARRAY OF CHAR; x, y, size: INTEGER);
VAR i: INTEGER;
BEGIN
 i := 0; WHILE (i < LEN(mystr)) & (mystr[i] # 0X) DO INC(i) END;
 JS.do("Instance.textFont(myFont); Instance.textSize(size); var newStr = mystr.toString().substring(0, i); Instance.text(newStr, x, y)")
END Stringi;

(* image *)

PROCEDURE LoadImage* (name: ARRAY OF CHAR): Image;
VAR image: Image;
BEGIN
 JS.do("image = Instance.loadImage(name)")
 RETURN image
END LoadImage;

PROCEDURE PlaceImage* (image: Image; x, y: REAL);
BEGIN JS.do("Instance.image(image, x, y)")
END PlaceImage;
 
(* transform *)

PROCEDURE Translate*(x,y : REAL);
BEGIN JS.do("Instance.translate(x,y)")
END Translate;

PROCEDURE PushMatrix*;
BEGIN JS.do("Instance.pushMatrix()")
END PushMatrix;

PROCEDURE PopMatrix*;
BEGIN JS.do("Instance.popMatrix()")
END PopMatrix;

PROCEDURE Rotate*(angle : REAL);
BEGIN JS.do("Instance.rotate(angle)")
END Rotate;

(* internal engine *)

PROCEDURE InnerDraw;
BEGIN
 IF DrawProc # NIL THEN
  JS.do("mouseX = Instance.mouseX; mouseY = Instance.mouseY;
   width = Instance.width; height = Instance.height;");
  DrawProc
 END
END InnerDraw;

PROCEDURE InnerSetup;
BEGIN IF SetupProc # NIL THEN SetupProc END
END InnerSetup;

PROCEDURE InnerPressed;
BEGIN IF PressedProc # NIL THEN PressedProc END
END InnerPressed;

PROCEDURE InnerReleased;
BEGIN IF ReleasedProc # NIL THEN ReleasedProc END
END InnerReleased;

PROCEDURE InnerOver;
BEGIN focus := TRUE; IF OverProc # NIL THEN OverProc END
END InnerOver;

PROCEDURE InnerOut;
BEGIN focus := FALSE; IF OutProc # NIL THEN OutProc END
END InnerOut;

(* start routine *)

PROCEDURE Start*;
BEGIN
 ASSERT(~started);
 JS.do("function sketchProc(p){p.draw=InnerDraw; p.setup=InnerSetup; p.mousePressed=InnerPressed; p.mouseReleased=InnerReleased; p.mouseOver=InnerOver; p.mouseOut=InnerOut; Instance=p;}");
 JS.do("var canvas = document.getElementById('processingCanvas');");
 JS.do("var processingInstance = new JS.Processing(canvas, sketchProc)");
 SetFont("Arial");
 focus := FALSE;
 started := TRUE
END Start;

END Draw.

